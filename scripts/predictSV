#!/usr/bin/env python

# Created on Tue Sep 8 20:45:18 2020
# Author: XiaoTao Wang

## Required modules

import argparse, sys, logging, logging.handlers, eaglec

currentVersion = eaglec.__version__

def getargs():
    ## Construct an ArgumentParser object for command-line arguments
    parser = argparse.ArgumentParser(description='''Predict and combine SV predictions from contact maps
                                     at multiple resolutions.''',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    # Version
    parser.add_argument('-v', '--version', action='version',
                        version=' '.join(['%(prog)s',currentVersion]),
                        help='Print version number and exit.')

    parser.add_argument('--mcool', help='''Path to a mcool file containing contact matrices at multiple resolutions''')
    parser.add_argument('--resolutions', default='5000,10000,25000,50000,100000,250000,500000,1000000',
                        help='''Resolutions at which the contact matrices will be used for SV prediction.''')
    parser.add_argument('--high-res', default='5000',
                        help='''Resolutions that are exclusively used to detect short-range SVs and
                        fine-map SV calls identified at coarser resolutions. This should be a subset
                        of those passed to "--resolutions".''')
    parser.add_argument('--model-path', default='EagleC2-models',
                        help='''Path to the folder containing pretrained models''')
    parser.add_argument('-O', '--output-prefix', help='''Prefix of the output file names''')
    parser.add_argument('-g', '--genome', default='hg38', choices = ['hg38', 'hg19', 'chm13', 'other'],
                       help='''Reference genome name.''')
    parser.add_argument('-C', '--chroms', nargs = '*', default = ['#', 'X'],
                        help = 'List of chromosome labels. Only Hi-C data within the specified '
                        'chromosomes will be included. Specially, "#" stands for chromosomes '
                        'with numerical labels. "--chroms" with zero argument will include '
                        'all chromosome data.')
    parser.add_argument('--balance-type', default='ICE', choices=['ICE', 'CNV', 'Raw'],
                        help = '''Normalization method. If you choose ICE, make sure you have run
                        "cooler balance" on your Hi-C matrix before you run this command; If you
                        choose CNV, make sure you have run "correct-cnv" of the NeoLoopFinder toolkit
                        before you run this command.''')
    parser.add_argument('--output-format', default='full', choices=['full', 'NeoLoopFinder'],
                        help='''Format of the reported SVs. full: For each SV, 12 columns will
                        be reported. The Information includes breakpoint coordinates, probability
                        values for each fusion type (++, +-, -+, --, ++/--, and +-/-+), the
                        resolution of the contact matrix from which the SV is originally predicted,
                        the finest resolution of the matrix where the SV can be mapped to, and the
                        number of bad bins nearby the SV breakpoints. NeoLoopFinder: 6-column format
                        that can be directly used as the NeoLoopFinder input.''')
    parser.add_argument('--prob-cutoff', default=0.5, type=float, help='''Probability threshold
                        for filtering the original SV calls. Value Range: (0, 1]''')
    parser.add_argument('--qvalue-cutoff', default=0.1, type=float, help='''Q-value cutoff. We
                        use a significant interaction detection procedure to perform a pre-filtering
                        before feeding the images into the CNN models. Tuning down this value may
                        accelerate the program but at the cost of sensitivity. Value Range: (0, 1]''')
    parser.add_argument('--entropy-cutoff', default=0.9, type=float, help='''Entropy cutoff.
                        We utilize a pre-filtering procedure based on Shannon entropy before
                        feeding the images into the CNN models. Tuning down this cutoff can
                        greatly accelerate the program but at the cost of sensitivity. Value Range: (0, 1]''')
    parser.add_argument('--intra-min', default=1, type=int,
                        help='''The minimum intra-chromosomal interaction frequency value.
                        Only chromatin contacts with the raw interaction frequency equal to or greater
                        than this value will be considered. Tuning up this value may accelerate the program
                        but at the cost of sensitivity.''')
    parser.add_argument('-k', '--max-dis', default=30, type=int,
                        help='''The maximum genomic distance (in the unit of pixels) at which the expected
                        interaction frequency is calculated for determining intra-chromosomal significant
                        interactions. Tuning down this value may accelerate the program but at the cost of
                        sensitivity.''')
    parser.add_argument('--inter-min-per', default=50, type=float,
                        help='''The percentile of the minimum inter-chromosomal interaction frequency
                        value. Tuning up this value may accelerate the program but at the cost of
                        sensitivity.''')
    parser.add_argument('-p', '--nproc', default=8, type=int,
                        help='The maximum number of processes to be allocated.')

    ## Parse the command-line arguments
    commands = sys.argv[1:]
    if not commands:
        commands.append('-h')
    args = parser.parse_args(commands)
    
    return args, commands


def run():

    # Parse Arguments
    args, commands = getargs()
    # Improve the performance if you don't want to run it
    if commands[0] not in ['-h', '-v', '--help', '--version']:
        ## Root Logger Configuration
        logger = logging.getLogger()
        logger.setLevel(10)
        console = logging.StreamHandler()
        logfil = '{0}.log'.format(args.output_prefix)
        filehandler = logging.FileHandler(logfil)
        # Set level for Handlers
        console.setLevel('INFO')
        filehandler.setLevel('INFO')
        # Customizing Formatter
        formatter = logging.Formatter(fmt = '%(name)-25s %(levelname)-7s @ %(asctime)s: %(message)s',
                                      datefmt = '%m/%d/%y %H:%M:%S')
        
        ## Unified Formatter
        console.setFormatter(formatter)
        filehandler.setFormatter(formatter)
        # Add Handlers
        logger.addHandler(console)
        logger.addHandler(filehandler)
        
        ## Logging for argument setting
        arglist = ['# ARGUMENT LIST:',
                   '# Path to mcool = {0}'.format(args.mcool),
                   '# Path to CNN models = {0}'.format(args.model_path),
                   '# Resolutions = {0}'.format(args.resolutions),
                   '# High Resolutions = {0}'.format(args.high_res),
                   '# Balance Type = {0}'.format(args.balance_type),
                   '# Reference Genome = {0}'.format(args.genome),
                   '# Included Chromosomes = {0}'.format(args.chroms),
                   '# Probability Cutoff = {0}'.format(args.prob_cutoff),
                   '# Qvalue Cutoff = {0}'.format(args.qvalue_cutoff),
                   '# Entropy Cutoff = {0}'.format(args.entropy_cutoff),
                   '# Minimum Cis-contact Strength = {0}'.format(args.intra_min),
                   '# Maximum Genomic Distance = {0}'.format(args.max_dis),
                   '# Minimum Trans-contact Percentile = {0}'.format(args.inter_min_per),
                   '# Number of Allocated Processes = {0}'.format(args.nproc),
                   '# Output File Prefix = {0}'.format(args.output_prefix),
                   '# Output Format = {0}'.format(args.output_format),
                   '# Log File Name = {0}'.format(logfil)
                   ]
        argtxt = '\n'.join(arglist)
        logger.info('\n' + argtxt)

        import cooler, time, os, tempfile, joblib
        import numpy as np
        from eaglec.utilities import calculate_expected, load_gap
        from eaglec.searchCandidates import select_intra_candidate, select_inter_candidate
        from eaglec.extractMatrix import collect_images
        from eaglec.predictCore import load_models, predict, remove_redundant_predictions, refine_predictions

        # read resolutions
        resolutions = [int(r) for r in args.resolutions.split(',')]
        high_res = [int(r) for r in args.high_res.split(',') if int(r) in resolutions]
        clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, resolutions[0]))
        # read chromosomes
        chroms = []
        for c in clr.chromnames:
            chromlabel = c.lstrip('chr')
            if (not args.chroms) or (chromlabel.isdigit() and '#' in args.chroms) or (chromlabel in args.chroms):
                chroms.append(c)
        
        # cache folder
        cache_root = os.path.abspath(os.path.expanduser('.eaglec2'))
        if not os.path.exists(cache_root):
            os.mkdir(cache_root)

        tl = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
        cache_folder = tempfile.mkdtemp(**{'suffix':tl, 'dir':cache_root})

        # valid bins
        if args.balance_type == 'CNV':
            balance = 'sweight'
        elif args.balance_type == 'ICE':
            balance = 'weight'
        else:
            balance = False
        
        # expected values
        expected_values = {}
        expected_values_raw = {}
        logger.info('Calculating the expected values ...')
        for res in resolutions:
            logger.info('Resolution {0}'.format(res))
            max_bins = max(200, 2000000//res)
            clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
            expected_values[res] = calculate_expected(clr, chroms, balance, max_bins, nproc=args.nproc)
            if not balance:
                expected_values_raw = expected_values
            else:
                expected_values_raw[res] = calculate_expected(clr, chroms, False, max_bins, nproc=args.nproc)
        
        joblib.dump(expected_values, os.path.join(cache_folder, 'expected_values.pkl'))
        joblib.dump(expected_values_raw, os.path.join(cache_folder, 'expected_values_raw.pkl'))

        # intra candidates
        logger.info('Searching for intra-chromosomal candidates ...')
        intra = {}
        for res in resolutions:
            logger.info('Resolution {0}'.format(res))
            clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
            if not res in high_res:
                intra[res] = select_intra_candidate(clr, chroms, expected_values_raw[res], k=args.max_dis,
                                                    q_thre=args.qvalue_cutoff, minv=args.intra_min,
                                                    nproc=args.nproc, highres=False)
            else:
                intra[res] = select_intra_candidate(clr, chroms, expected_values_raw[res], k=args.max_dis,
                                                    q_thre=args.qvalue_cutoff, minv=args.intra_min,
                                                    nproc=args.nproc, highres=True)
        
        intra_counts = count_candidates(intra)
        filtered_intra = intra
        logger.info('Totally detected {0} intra-chromosomal candidates'.format(intra_counts[1]))
        logger.info('The number of intra-chromosomal candidates by resolution: {0}'.format(intra_counts[0]))
        
        # inter candidates
        logger.info('Searching for inter-chromosomal candidates ...')
        inter = {}
        for res in resolutions:
            if not res in high_res:
                clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
                logger.info('Resolution {0}'.format(res))
                inter[res] = select_inter_candidate(clr, chroms, min_per=args.inter_min_per,
                                                    less_stringent=True, q_thre=args.qvalue_cutoff,
                                                    nproc=args.nproc)
        
        inter_counts = count_candidates(inter)
        filtered_inter = inter
        logger.info('Totally detected {0} inter-chromosomal candidates'.format(inter_counts[1]))
        logger.info('The number of inter-chromosomal candidates by resolution: {0}'.format(inter_counts[0]))

        logger.info('The extracted images will be exported to the folder {0}'.format(cache_folder))
        intra_n = collect_images(args.mcool, filtered_intra, expected_values, balance, cache_folder,
                                 w=15, entropy_cutoff=args.entropy_cutoff, nproc=args.nproc)
        inter_n = collect_images(args.mcool, filtered_inter, expected_values, balance, cache_folder,
                                 w=15, entropy_cutoff=args.entropy_cutoff, nproc=args.nproc)
        
        logger.info('Totally collected {0} images'.format(intra_n + inter_n))
        logger.info('Predicting SVs at each resolution ...')
        models = load_models(args.model_path)
        original_predictions = predict(cache_folder, models, prob_cutoff=args.prob_cutoff, batch_size=256)
        original_predictions = remove_redundant_predictions(original_predictions)
        joblib.dump(original_predictions, '{0}.pkl'.format(args.output_prefix))
        logger.info('Done')

        logger.info('Fine-map original SV calls at higher resolutions ...')
        # load gap regions
        gaps = {}
        for res in resolutions:
            clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
            gaps[res] = load_gap(clr, chroms, ref_genome=args.genome, balance=balance)

        SVs = refine_predictions(original_predictions, resolutions, models, args.mcool, balance,
                                 expected_values, gaps, w=15, baseline_prob=0.5)
        with open('{0}.SV_calls.txt'.format(args.output_prefix), 'w') as out:
            if args.output_format == 'full':
                out.write('\t'.join(['chrom1', 'pos1', 'chrom2', 'pos2', '++', '+-', '-+', '--', '++/--', '+-/-+',
                                     'original resolution', 'fine-mapped resolution', 'gap info'])+'\n')
            for line in SVs:
                c1, p1, c2, p2, prob1, prob2, prob3, prob4, prob5, prob6, res1, res2, ng = line
                if args.output_format == 'full':
                    out.write('{0}\t{1}\t{2}\t{3}\t{4:.4g}\t{5:.4g}\t{6:.4g}\t{7:.4g}\t{8:.4g}\t{9:.4g}\t{10}\t{11}\t{12}\n'.format(c1, p1, c2, p2, prob1, prob2, prob3, prob4, prob5, prob6, res1, res2, ng))
                else:
                    strands = ['++', '+-', '-+', '--', '++/--', '+-/-+']
                    probs = np.r_[[prob1, prob2, prob3, prob4, prob5, prob6]]
                    idx = np.argmax(probs)
                    strand_list = strands[idx].split('/')
                    for strand in strand_list:
                        annot = 'translocation'
                        if c1 == c2:
                            if strand == '+-':
                                annot = 'deletion'
                            elif strand == '-+':
                                annot = 'duplication'
                            elif strand in ['++', '--']:
                                annot = 'inversion'

                        out.write('\t'.join([c1, c2, strand, str(p1), str(p2), annot])+'\n')

        logger.info('Done')

def count_candidates(by_res):

    counts = {}
    for r in by_res:
        tmp = by_res[r]
        counts[r] = sum([len(tmp[k]) for k in tmp])
    
    total = sum(list(counts.values()))
    
    return counts, total


if __name__ == '__main__':
    run()