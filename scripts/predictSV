#!/usr/bin/env python

# Created on Tue Sep 8 20:45:18 2020
# Author: XiaoTao Wang

## Required modules

import argparse, sys, logging, logging.handlers, eaglec

currentVersion = eaglec.__version__

def getargs():
    ## Construct an ArgumentParser object for command-line arguments
    parser = argparse.ArgumentParser(description='''Predict and combine SV predictions from contact maps
                                     at multiple resolutions.''',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    # Version
    parser.add_argument('-v', '--version', action='version',
                        version=' '.join(['%(prog)s',currentVersion]),
                        help='Print version number and exit.')

    parser.add_argument('--mcool', help='''Path to a mcool file containing contact matrices at multiple resolutions''')
    parser.add_argument('--resolutions', default='5000,10000,25000,50000,100000,250000,500000,1000000',
                        help='''Resolutions at which the contact matrices will be used for SV prediction.''')
    parser.add_argument('--high-res', default='1000,2000',
                        help='''Resolutions that are exclusively used to detect short-range SVs and
                        refine SV calls identified at coarser resolutions. If a resolution specified
                        by this parameter is not included in the "--resolutions" list, it will be skipped.''')
    parser.add_argument('--balance-type', default='ICE', choices=['ICE', 'CNV', 'Raw'],
                        help = '''Normalization method. If you choose ICE, make sure you have run
                        "cooler balance" on your Hi-C matrix before you run this command; If you
                        choose CNV, make sure you have run "correct-cnv" of the NeoLoopFinder toolkit
                        before you run this command.''')
    parser.add_argument('--model-path', default='EagleC2-models',
                        help='''Path to the folder containing pretrained models''')
    parser.add_argument('-O', '--output-prefix', help='''Prefix of the output file names''')
    parser.add_argument('-g', '--genome', default='hg38', choices = ['hg38', 'hg19', 'chm13', 'other'],
                       help='''Reference genome name.''')
    parser.add_argument('-C', '--chroms', nargs = '*', default = ['#', 'X'],
                        help = 'List of chromosome labels. Only Hi-C data within the specified '
                        'chromosomes will be included. Specially, "#" stands for chromosomes '
                        'with numerical labels. "--chroms" with zero argument will include '
                        'all chromosome data.')
    parser.add_argument('--output-format', default='full', choices=['full', 'NeoLoopFinder'],
                        help='''Format of the reported SVs. full: For each SV, 12 columns will
                        be reported. The Information includes breakpoint coordinates, probability
                        values for each fusion type (++, +-, -+, --, ++/--, and +-/-+), the
                        resolution of the contact matrix from which the SV is originally predicted,
                        the finest resolution of the matrix where the SV can be mapped to, and the
                        number of bad bins nearby the SV breakpoints. NeoLoopFinder: 6-column format
                        that can be directly used as the NeoLoopFinder input.''')
    parser.add_argument('--intra-qvalue-cutoff', default=0.02, type=float, help='''Q-value cutoff
                        for pre-filtering intra-chromosomal pixels before feeding images into the
                        CNN models. Lowering this value can speed up the program but may reduce
                        sensitivity. Value Range: (0, 1]''')
    parser.add_argument('--inter-qvalue-cutoff', default=0.02, type=float, help='''Q-value cutoff
                        for pre-filtering inter-chromosomal pixels before feeding images into the
                        CNN models. Lowering this value can speed up the program but may reduce
                        sensitivity. Value Range: (0, 1]''')
    parser.add_argument('--intra-min', default=1, type=int,
                        help='''The minimum intra-chromosomal interaction frequency value.
                        Increasing this value may speed up the program but could reduce
                        sensitivity.''')
    parser.add_argument('-k', '--max-dis', default=100, type=int,
                        help='''The maximum genomic distance, measured in pixels, within which 
                        the expected interaction frequency is calculated for identifying intra-chromosomal
                        significant interactions. Decreasing this value may speed up the program
                        but could compromise sensitivity.''')
    parser.add_argument('--inter-min-per', default=50, type=float,
                        help='''Percentile of the minimum inter-chromosomal interaction frequency
                        value. Increasing this value may speed up the program but could reduce
                        sensitivity. Value Range: [0, 100]''')
    parser.add_argument('--min-cluster-size', default=3, type=int,
                        help='''The minimum size of clusters. The value will be directly passed to
                        the HDBSCAN clustering algorithm. Setting it to 0 will disable the HDBSCAN
                        clustering.''')
    parser.add_argument('--min-samples', default=3, type=int,
                        help='''The number of samples in a neighbourhood for a point to be considered
                        a core point. The value will be directly passed to the HDBSCAN clustering
                        algorithm. Setting it to 0 will disable the HDBSCAN clustering.''')
    parser.add_argument('--shrink-per', default=15, type=float,
                        help='''Percentile of pixels with the most enriched signals to retain
                        within each cluster identified by the initial round of HDBSCAN clustering.
                        Value Range: (0, 100]''')
    parser.add_argument('--top-per', default=15, type=float,
                        help='''Percentile of pixels with the most enriched signals that will be
                        considered for CNN prediction within each cluster identified by the second
                        round of HDBSCAN. Decreasing the value may accelerate the program but could
                        reduce sensitivity. Value Range: [0, 100]''')
    parser.add_argument('--top-n', default=15, type=int,
                        help='''The number of pixels with the most enriched signals that will be
                        considered for CNN prediction within each cluster identified by the second
                        round of HDBSCAN. Decreasing the value may accelerate the program but could
                        reduce sensitivity. The smaller number of pixels determined by "--top-per"
                        and "--top-n" will be applied to the pre-filtering procedure.''')
    parser.add_argument('--extend-size', default=2, type=int,
                        help='''The number of units that will be extended along each axis for
                        each candidate pixel. Increasing the value will include more candidate
                        pixels in prediction but may significantly slow down the program.''')
    parser.add_argument('--entropy-cutoff', default=0.97, type=float, help='''Entropy cutoff.
                        We utilize a pre-filtering procedure based on Shannon entropy before
                        feeding the images into the CNN models. Tuning down this cutoff can
                        greatly accelerate the program but may reduce sensitivity.
                        Value Range: (0, 1]''')
    parser.add_argument('--prob-cutoff', default=0.5, type=float, help='''Probability cutoff
                        for filtering the original SV calls. Value Range: [0, 1]''')
    parser.add_argument('--allowed-gaps', default=2, type=int,
                        help='''The maximum number of gap bins allowed near the SV breakpoints.''')
    parser.add_argument('-p', '--nproc', default=8, type=int,
                        help='The maximum number of processes to be allocated.')

    ## Parse the command-line arguments
    commands = sys.argv[1:]
    if not commands:
        commands.append('-h')
    args = parser.parse_args(commands)
    
    return args, commands


def run():

    # Parse Arguments
    args, commands = getargs()
    # Improve the performance if you don't want to run it
    if commands[0] not in ['-h', '-v', '--help', '--version']:
        ## Root Logger Configuration
        logger = logging.getLogger()
        logger.setLevel(10)
        console = logging.StreamHandler()
        logfil = '{0}.log'.format(args.output_prefix)
        filehandler = logging.FileHandler(logfil)
        # Set level for Handlers
        console.setLevel('INFO')
        filehandler.setLevel('INFO')
        # Customizing Formatter
        formatter = logging.Formatter(fmt = '%(name)-25s %(levelname)-7s @ %(asctime)s: %(message)s',
                                      datefmt = '%m/%d/%y %H:%M:%S')
        
        ## Unified Formatter
        console.setFormatter(formatter)
        filehandler.setFormatter(formatter)
        # Add Handlers
        logger.addHandler(console)
        logger.addHandler(filehandler)
        
        ## Logging for argument setting
        arglist = ['# ARGUMENT LIST:',
                   '# Path to mcool = {0}'.format(args.mcool),
                   '# Resolutions = {0}'.format(args.resolutions),
                   '# High Resolutions = {0}'.format(args.high_res),
                   '# Balance Type = {0}'.format(args.balance_type),
                   '# Path to CNN models = {0}'.format(args.model_path),
                   '# Reference Genome = {0}'.format(args.genome),
                   '# Included Chromosomes = {0}'.format(args.chroms),
                   '# Qvalue Cutoff (Cis) = {0}'.format(args.intra_qvalue_cutoff),
                   '# Qvalue Cutoff (Trans) = {0}'.format(args.inter_qvalue_cutoff),
                   '# Minimum Cis-contact Strength = {0}'.format(args.intra_min),
                   '# Maximum Genomic Distance = {0}'.format(args.max_dis),
                   '# Minimum Trans-contact Percentile = {0}'.format(args.inter_min_per),
                   '# Minimum Cluster Size = {0}'.format(args.min_cluster_size),
                   '# Minimum Number of Samples = {0}'.format(args.min_samples),
                   '# Shrink Percentage = {0}'.format(args.shrink_per),
                   '# Percentile of Pixels within Each Cluster = {0}'.format(args.top_per),
                   '# Number of Pixels within Each Cluster = {0}'.format(args.top_n),
                   '# Extend Size = {0}'.format(args.extend_size),
                   '# Entropy Cutoff = {0}'.format(args.entropy_cutoff),
                   '# Probability Cutoff = {0}'.format(args.prob_cutoff),
                   '# Allowed Number of Gap Bins = {0}'.format(args.allowed_gaps),
                   '# Number of Allocated Processes = {0}'.format(args.nproc),
                   '# Output File Prefix = {0}'.format(args.output_prefix),
                   '# Output Format = {0}'.format(args.output_format),
                   '# Log File Name = {0}'.format(logfil)
                   ]
        argtxt = '\n'.join(arglist)
        logger.info('\n' + argtxt)

        import cooler, time, os, tempfile, joblib
        import numpy as np
        from eaglec.utilities import calculate_expected, load_gap
        from eaglec.searchCandidates import select_intra_candidate, select_inter_candidate
        from eaglec.extractMatrix import collect_images
        from eaglec.predictCore import load_models, predict, refine_predictions

        # read resolutions
        resolutions = [int(r) for r in args.resolutions.split(',')]
        high_res = [int(r) for r in args.high_res.split(',') if int(r) in resolutions]
        clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, resolutions[0]))
        # read chromosomes
        chroms = []
        for c in clr.chromnames:
            chromlabel = c.lstrip('chr')
            if (not args.chroms) or (chromlabel.isdigit() and '#' in args.chroms) or (chromlabel in args.chroms):
                chroms.append(c)
        
        # cache folder
        cache_root = os.path.abspath(os.path.expanduser('.eaglec2'))
        if not os.path.exists(cache_root):
            os.mkdir(cache_root)

        tl = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
        cache_folder = tempfile.mkdtemp(**{'suffix':tl, 'dir':cache_root})

        # valid bins
        if args.balance_type == 'CNV':
            balance = 'sweight'
        elif args.balance_type == 'ICE':
            balance = 'weight'
        else:
            balance = False
        
        # expected values
        expected_values = {}
        expected_values_raw = {}
        logger.info('Calculating the expected values ...')
        for res in resolutions:
            logger.info('Resolution {0}'.format(res))
            max_bins = max(200, 2000000//res)
            clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
            expected_values[res] = calculate_expected(clr, chroms, balance, max_bins, nproc=args.nproc)
            if not balance:
                expected_values_raw = expected_values
            else:
                expected_values_raw[res] = calculate_expected(clr, chroms, False, max_bins, nproc=args.nproc)
        
        joblib.dump(expected_values, os.path.join(cache_folder, 'expected_values.pkl'))
        joblib.dump(expected_values_raw, os.path.join(cache_folder, 'expected_values_raw.pkl'))

        # intra candidates
        logger.info('Searching for intra-chromosomal candidates ...')
        intra = {}
        for res in resolutions:
            logger.info('Resolution {0}'.format(res))
            clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
            if not res in high_res:
                intra[res] = select_intra_candidate(clr, chroms, expected_values_raw[res], k=args.max_dis,
                                                    q_thre=args.intra_qvalue_cutoff, minv=args.intra_min,
                                                    min_cluster_size=args.min_cluster_size,
                                                    min_samples=args.min_samples, shrink_per=args.shrink_per,
                                                    top_per=args.top_per, top_n=args.top_n, buff=args.extend_size,
                                                    nproc=args.nproc, highres=False)
            else:
                intra[res] = select_intra_candidate(clr, chroms, expected_values_raw[res], k=args.max_dis,
                                                    q_thre=args.intra_qvalue_cutoff, minv=args.intra_min,
                                                    min_cluster_size=args.min_cluster_size,
                                                    min_samples=args.min_samples, shrink_per=args.shrink_per,
                                                    top_per=args.top_per, top_n=args.top_n, buff=args.extend_size,
                                                    nproc=args.nproc, highres=True)
        
        intra_counts = count_candidates(intra)
        filtered_intra = intra
        logger.info('Totally detected {0} intra-chromosomal candidates'.format(intra_counts[1]))
        logger.info('The number of intra-chromosomal candidates by resolution: {0}'.format(intra_counts[0]))
        
        # inter candidates
        logger.info('Searching for inter-chromosomal candidates ...')
        inter = {}
        for res in resolutions:
            if not res in high_res:
                clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
                logger.info('Resolution {0}'.format(res))
                inter[res] = select_inter_candidate(clr, chroms, windows=[3,4,5], min_per=args.inter_min_per,
                                                    q_thre=args.inter_qvalue_cutoff, min_cluster_size=args.min_cluster_size,
                                                    min_samples=args.min_samples, shrink_per=args.shrink_per, top_per=args.top_per,
                                                    top_n=args.top_n, buff=args.extend_size, nproc=args.nproc)
        
        inter_counts = count_candidates(inter)
        filtered_inter = inter
        logger.info('Totally detected {0} inter-chromosomal candidates'.format(inter_counts[1]))
        logger.info('The number of inter-chromosomal candidates by resolution: {0}'.format(inter_counts[0]))

        logger.info('The extracted images will be exported to the folder {0}'.format(cache_folder))
        intra_n = collect_images(args.mcool, filtered_intra, expected_values, balance, cache_folder,
                                 w=15, entropy_cutoff=args.entropy_cutoff, nproc=args.nproc)
        inter_n = collect_images(args.mcool, filtered_inter, expected_values, balance, cache_folder,
                                 w=15, entropy_cutoff=args.entropy_cutoff, nproc=args.nproc)
        
        logger.info('Totally collected {0} images'.format(intra_n + inter_n))
        logger.info('Predicting SVs at each resolution ...')
        models = load_models(args.model_path)
        # load gap regions
        gaps = {}
        for res in resolutions:
            clr = cooler.Cooler('{0}::resolutions/{1}'.format(args.mcool, res))
            gaps[res] = load_gap(clr, chroms, ref_genome=args.genome, balance=balance)

        original_predictions = predict(cache_folder, models, gaps, prob_cutoff=args.prob_cutoff,
                                       max_gap=args.allowed_gaps, batch_size=256)
        logger.info('Done')

        logger.info('Fine-map original SV calls at higher resolutions ...')
        SVs = refine_predictions(original_predictions, resolutions, models, args.mcool, balance,
                                 expected_values, gaps, max_gap=args.allowed_gaps, w=15, baseline_prob=0.5)
        with open('{0}.SV_calls.txt'.format(args.output_prefix), 'w') as out:
            if args.output_format == 'full':
                out.write('\t'.join(['chrom1', 'pos1', 'chrom2', 'pos2', '++', '+-', '-+', '--', '++/--', '+-/-+',
                                     'original resolution', 'fine-mapped resolution', 'gap info'])+'\n')
            for line in SVs:
                c1, p1, c2, p2, prob1, prob2, prob3, prob4, prob5, prob6, res1, res2, ng = line
                if args.output_format == 'full':
                    out.write('{0}\t{1}\t{2}\t{3}\t{4:.4g}\t{5:.4g}\t{6:.4g}\t{7:.4g}\t{8:.4g}\t{9:.4g}\t{10}\t{11}\t{12}\n'.format(c1, p1, c2, p2, prob1, prob2, prob3, prob4, prob5, prob6, res1, res2, ng))
                else:
                    strands = ['++', '+-', '-+', '--', '++/--', '+-/-+']
                    probs = np.r_[[prob1, prob2, prob3, prob4, prob5, prob6]]
                    idx = np.argmax(probs)
                    strand_list = strands[idx].split('/')
                    for strand in strand_list:
                        annot = 'translocation'
                        if c1 == c2:
                            if strand == '+-':
                                annot = 'deletion'
                            elif strand == '-+':
                                annot = 'duplication'
                            elif strand in ['++', '--']:
                                annot = 'inversion'

                        out.write('\t'.join([c1, c2, strand, str(p1), str(p2), annot])+'\n')

        logger.info('Done')

def count_candidates(by_res):

    counts = {}
    for r in by_res:
        tmp = by_res[r]
        counts[r] = sum([len(tmp[k]) for k in tmp])
    
    total = sum(list(counts.values()))
    
    return counts, total


if __name__ == '__main__':
    run()